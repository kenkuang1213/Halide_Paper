\addvspace {10\p@ }
\addvspace {10\p@ }
\addvspace {10\p@ }
\addvspace {10\p@ }
\contentsline {figure}{\numberline {4.1}{\ignorespaces kernel fusion}}{7}
\contentsline {figure}{\numberline {4.2}{\ignorespaces accessing pattern of 2 kernels}}{7}
\contentsline {figure}{\numberline {4.3}{\ignorespaces Example of the calculating flow when doing redundant works}}{8}
\contentsline {figure}{\numberline {4.4}{\ignorespaces accessing pattern of compute\_at}}{9}
\contentsline {figure}{\numberline {4.5}{\ignorespaces accessing pattern of compute\_at 2}}{10}
\contentsline {figure}{\numberline {4.6}{\ignorespaces Flowchart of approach}}{12}
\addvspace {10\p@ }
\contentsline {figure}{\numberline {5.1}{\ignorespaces compilation time comparison between with \& without pre-parser}}{16}
\contentsline {figure}{\numberline {5.2}{\ignorespaces total execution time comparison between OpenCL with \& without kernel fusion, fusing two kernels into one kernel}}{17}
\contentsline {figure}{\numberline {5.3}{\ignorespaces kernel execution time comparison between OpenCL with \& without kernel fusion, fusing two kernels into one kernel}}{17}
\contentsline {figure}{\numberline {5.4}{\ignorespaces kernel execution time comparison between Halide with \& without kernel fusion, fusing two kernels into one kernel}}{18}
\contentsline {figure}{\numberline {5.5}{\ignorespaces kernel execution time comparison between Halide OpenCL CodeGen \& handwritten OpenCL code, executing single kernel}}{19}
\contentsline {figure}{\numberline {5.6}{\ignorespaces kernel execution time comparison between Halide \& OpenCL kernel fusion, fusing two kernels into one kernel}}{19}
\contentsline {figure}{\numberline {5.7}{\ignorespaces fastest kernel execution time comparison between Halide \& OpenCL kernel fusion, fusing two kernels into one kernel}}{20}
\addvspace {10\p@ }
\addvspace {10\p@ }
